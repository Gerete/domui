package to.etc.log;

import java.util.*;

/**
 *	Encapsulates a multithreading-safe logfile. This class allows messages from
 *  multiple threads at a time. They are written to the logfile in the same
 *  sequence they arrived in. The logfile can have a "parent" log; all messages
 *  sent to this logfile are also sent to the parent.
 *  To prevent huge logs you can set logwrap mode. By setting logwrap to a
 *  given number you generate that many logfiles; each logfile gets wrapped
 *  at midnight local time.
 *	All messages herein are sent to the LogMaster sink also, so that that one
 *  can decide where to sent the data. The topmost MTLogFile in the PARENT chain
 *  is responsible for this.
 *
 * <p>Title: Mumble Global Libraries - Non-database tools</p>
 * <p>Description: Small tools for Java programs</p>
 * <p>Copyright: Copyright (c) 2002 Frits Jalvingh; released under the LGPL licence.</p>
 * <p>Website <a href="http://www.mumble.to/">Mumble</a></p>
 * @author <a href="mailto:jal@mumble.to">Frits Jalvingh</a>
 * @version 1.0
 *
 */
public class MTLogFile implements Runnable {
	/// T if logfile writing encountered an exception and writing has stopped.
	private boolean		m_in_error;

	/// The parent logfile.
	private MTLogFile	m_daddy;

	/// T if the writer has been aquired and is being used by another thread.
	private boolean		m_am_writing;

	/// The linked list of queued messages, if the writer is busy.
	private LinkedList	m_pending_queue;

	/// The thread created if the #of queued messages grows too large
	private Thread		m_thread;


	/**
	 *	Create a logfile.
	 */
	public MTLogFile() {
	}

	/**
	 *	Create a logfile with the specified parent.
	 */
	public MTLogFile(MTLogFile parent) {
		m_daddy = parent;
	}


	/**
	 *	Handle a log record by writing it to this file and passing it to all
	 *  other thingies. This call does NOT throw an exception; if anything goes
	 *  wrong the log will be disabled after a console message.
	 *  When a thread is currently writing all messages generated by other
	 *  threads are queued; the thread that is currently writing a message will
	 *  write all queued messages before exiting.
	 *  To prevent a thread from being responsible for writing a lot of queued
	 *  messages the writing thread will spawn a new thread if the #of messages
	 *  queued is above 20.
	 */
	public void write(LogRecord lr) {
		//-- Send this to the parent first, if we have'one,
		if(m_daddy == null)
			LogMaster.logSink(lr);
		else
			m_daddy.write(lr);
		if(m_in_error)
			return; // We are in error- drop message...

		//-- Ok: aquire the writer *or* queue the message,
		synchronized(this) {
			if(m_am_writing) // Writer is aquired- need buffering?
			{
				if(m_pending_queue == null)
					m_pending_queue = new LinkedList();
				m_pending_queue.addLast(lr);
				return;
			}

			//-- We CAN aquire the writer- do so,
			m_am_writing = true; // Aquire the writer.
		}

		//-- Ok: we are the thread that has to write this message. Write the current one,
		try {
			int written = 0;
			for(;;) {
				_write(lr); // Write current to stream,
				written++;

				synchronized(this) // Check if queue contains data,
				{
					int nm = m_pending_queue.size(); // How much is queued?
					if(nm == 0) // Nothing queued?
					{
						m_am_writing = false; // I am finished!
						return; // And be done: all messages processed
					}

					//-- We have to write queued messages. Did we already do too much?
					if(written < 20) // Not written enough-
					{
						lr = (LogRecord) m_pending_queue.removeFirst();
					} else {
						System.out.println("LogWriter: spawning message thread...");

						//-- Now: spawn a worker thread and make IT responsible for the work!!
						try {
							m_thread = new Thread(this);
							m_thread.start();

							//-- We're done now!
							return;
						} catch(Throwable t) {
							t.printStackTrace();
							m_thread = null;
							lr = (LogRecord) m_pending_queue.removeFirst();
							written = 0;
						}
					}
				}
			}
		} catch(RuntimeException x) {
			synchronized(this) {
				m_am_writing = false;
			}
			throw x;
		}
	}


	private void _write(LogRecord lr) {
	}


	/**
	 *	This is the worker thread's code. When entered the am_writing thing
	 *  is still TRUE, meaning that this worker thread owns the section.
	 */
	public void run() {
		/**@todo: Implement this java.lang.Runnable method*/
		throw new java.lang.UnsupportedOperationException("Method run() not yet implemented.");
	}


}
